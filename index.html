<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Higher-Order Functions</title>
  <link rel="shortcut icon" href="favicon.ico"/>
  <link rel="stylesheet" href="https://codemirror.net/lib/codemirror.css">
  <style>
* {
  box-sizing: border-box;
  font-family: sans-serif;
}
html {
  scroll-behavior: smooth;
}
body {
  background: #eee;
  margin: 2.5rem auto;
  max-width: 650px;
  line-height: 1.6;
  font-size: 1.125rem;
  color: #333;
  padding: 0 1rem;
}
h1, h2, h3, h4 {
  line-height: 1.2;
}
h2:not(nav h2) {
  page-break-before: always;
}

pre, .CodeMirror, .CodeMirror * {
  font-family: Inconsolata, Consolas, monospace;
  font-size: 1rem;
  line-height: 1.4;
}
code {
  font-family: Inconsolata, Consolas, monospace;
}

.author {
  margin-top: -1rem; display: flex; justify-content: flex-end; font-style: italic;
}
nav {
  font-style: italic;
}
nav hr {
  border: 0;
  border-bottom: 1px solid #999;
}
nav h2 {
  font-size: 1.5rem;
  margin: 0.75rem 0;
}
nav ul {
  list-style: none;
  padding-left: 1rem;
  margin: 0;
}
nav li {
  margin: 0;
}
small {
  display: inline-block;
  line-height: 1.4;
}
.recycling-objects {
  display: flex;
  flex-wrap: wrap;
  margin: 0 -0.5rem;
}
.recycling-objects pre {
  line-height: 1.2;
  background: #ccc;
  margin: 0.5rem;
  padding: 0.5rem;
}
.recycling-list {
  line-height: 1.2;
  background: #ccc;
  padding: 0.5rem;
}
button {
  appearance: none;
  cursor: pointer;
  font-family: sans-serif;
  font-size: 1.125rem;
  background: #ccc;
  color: #333;
  border: none;
  border-radius: 0.25rem;
  margin: 0.5rem 0.5rem 0.5rem 0;
  padding: 0.5rem 0.75rem;
  transition: transform 0.3s ease;
}
button:hover {
  transform: translateY(-2px);
}
.result {
  background: #333;
  margin: 0;
  padding: 1rem;
  border-radius: 0.25rem;
  color: lime;
  max-height: 16rem;
  overflow: auto;
}
.result:empty {
  display: none;
}
.result.error {
  background: #fcc;
  color: red;
}
  </style>
</head>
<body>
  <h1>Higher-Order Functions</h1>
  <p class="author">with Michael McLeod (5886760).</p>
  <nav>
    <hr/>
    <h2>Contents</h2>
    <ul>
      <li><a href="#lesson-one">Lesson One</a></li>
      <ul>
        <li><a href="#recycling-problem">A recycling problem</a></li>
        <li><a href="#reusing-code">Reusing code</a></li>
        <li><a href="#anonymous-functions">Anonymous functions</a></li>
        <li><a href="#conclusion-one">Putting it all together</a></li>
      </ul>
      <li><a href="#lesson-two">Lesson Two</a></li>
      <ul>
        <li><a href="#filter">Filter</a></li>
        <li><a href="#map">Map</a></li>
        <li><a href="#chaining">Chaining functions</a></li>
      </ul>
      <li><a href="#lesson-three">Lesson Three</a></li>
      <ul>
        <li><a href="#reduce">Reduce</a></li>
        <li><a href="#all-you-need">Reduce is all you need</a></li>
        <li><a href="#conclusion-three">What have I learned?</a></li>
      </ul>
    </ul>
    <hr/>
  </nav>
  <h2 id="lesson-one">Lesson One</h2>
  <h3 id="recycling-problem">A recycling problem</h3>
  <p>
    Reusing as many things as we can is a great way to save resources,
    and nobody understands that better than your local paper recycling plant.
  </p>
  <p>
    But the paper recycling plant has a problem!
    They are receiving a whole lot of recycling,
    but not all of it is paper. And so they have called upon you
    to help them work out what belongs and what doesn't.
  </p>
  <p>
    This is what they know about their recycling items:
  </p>
  <div class="recycling-objects">
<pre>{
 name: "Newspapers",
 type: "paper",
 amount: 10,
 weight: 220
}</pre>
<pre>{
 name: "Milk bottles",
 type: "plastic",
 amount: 6,
 weight: 62
}</pre>
<pre>{
 name: "Boxes",
 type: "paper",
 amount: 5,
 weight: 130
}</pre>
<pre>{
 name: "Egg cartons",
 type: "paper",
 amount: 3,
 weight: 20
}</pre>
<pre>{
 name: "Tin cans",
 type: "metal",
 amount: 9,
 weight: 20
}</pre>
<pre>{
 name: "Magazines",
 type: "paper",
 amount: 2,
 weight: 150
}</pre>
<pre>{
 name: "Glass bottles",
 type: "glass",
 amount: 7,
 weight: 600
}</pre>
<pre>{
 name: "Yoghurt pots",
 type: "plastic",
 amount: 12,
 weight: 5
}</pre>
  </div>
  <p>
    You have come up with a function that will help them work out
    if an item belongs at the paper recycling plant, and it looks like this:
  </p>
  <textarea id="t1" style="display:none" autocomplete="off">
function checkPaper(item) {
  if (item.type === 'paper') {
    console.log('Yes! ' + item.name + ' can be recycled here.');
  } else {
    console.log('No! ' + item.name + ' must be recycled somewhere else.');
  }
}

checkPaper({ name: 'Newspapers', type: 'paper' });
checkPaper({ name: 'Milk bottles', type: 'plastic' });
checkPaper({ name: 'Tin cans', type: 'metal' });</textarea>
  <button data-textarea="t1" data-result="r1">Run</button>
  <pre id="r1" class="result"></pre>
  <p>
    It works! In fact, it works so well that the local <em>plastic</em>
    recycling plant would like you to do the same thing for them.
    So you give them the following function, that is almost identical to <code>checkPaper</code>:
  </p>
  <textarea id="t2" style="display:none" autocomplete="off">
function checkPlastic(item) {
  if (item.type === 'plastic') {
    console.log('Yes! ' + item.name + ' can be recycled here.');
  } else {
    console.log('No! ' + item.name + ' must be recycled somewhere else.');
  }
}

checkPlastic({ name: 'Newspapers', type: 'paper' });
checkPlastic({ name: 'Milk bottles', type: 'plastic' });
checkPlastic({ name: 'Tin cans', type: 'metal' });</textarea>
  <button data-textarea="t2" data-result="r2">Run</button>
  <pre id="r2" class="result"></pre>
  <p>
    But now you have a problem of your own. The recycling plants want you
    to update your code so that it also prints how many of each item there are.
    But your code is now in two places, and every time you make a change to
    <code>checkPaper</code>, you will have to remember to make the same change
    to <code>checkPlastic</code> as well.
  </p>
  <h3 id="reusing-code">Reusing code</h3>
  <p>
    Reusing things in programming is just as important as it is in recycling,
    because it will help you avoid problems like this one. Whenever you encounter
    two very similar functions like <code>checkPaper</code> and <code>checkPlastic</code>,
    it is a good idea to try to separate out the common functionality.
  </p>
  <p>
    Here is a function called <code>check</code> that does just that:
  </p>
  <textarea id="t3" style="display:none" autocomplete="off">
function check(item, test) {
  if (test(item)) {
    console.log('Yes! ' + item.name + ' can be recycled here.');
  } else {
    console.log('No! ' + item.name + ' must be recycled somewhere else.');
  }
}</textarea>
  <p>
    The only part that was different between <code>checkPaper</code> and
    <code>checkPlastic</code> was the code inside the <code>if</code>-statement,
    so we have replaced that code with something new called <code>test</code>,
    that we can pass to the function as an argument.
  </p>
  <p>
    But what is <code>test</code>? Well, we can see on line 2 that we are using it
    like a function, and that is exactly what it is.
    It takes <code>item</code> as a parameter and returns <code>true</code> or <code>false</code>.
  </p>
  <p>
    A function that takes another function as an argument, like <code>check</code>,
    is called a <strong>higher-order function</strong>.
  </p>
  <p>
    This is how we would use <code>test</code> to check for paper:
  </p>
  <textarea id="t4" style="display:none" autocomplete="off">
let testPaper = function (item) {
  return item.type === 'paper';
}

check({ name: 'Newspapers', type: 'paper' }, testPaper);
check({ name: 'Milk bottles', type: 'plastic' }, testPaper);
check({ name: 'Tin cans', type: 'metal' }, testPaper);</textarea>
  <button data-textarea="t4" data-result="r4">Run</button>
  <pre id="r4" class="result"></pre>
  <p>
    We are passing <code>testPaper</code> as the second argument to <code>check</code>,
    and it is evaluating it when it runs <code>test(item)</code>.
  </p>
  <p>
    Notice that we do <em>not</em> put any brackets after <code>testPaper</code>
    when we pass it to <code>check</code>, because we don't want the function
    to be executed until later. We are using the function <em>as a variable</em>.
  </p>
  <h3 id="anonymous-functions">Anonymous functions</h3>
  <p>
    That is also the reason why the code says <code>"let testPaper = function"</code>
    instead of <code>"function testPaper"</code>. These are more or less the same
    in JavaScript, but the first way makes it extra clear that we are using a variable.
  </p>
  <p>
    JavaScript actually has a bunch of shortcuts for when you are using a function as a variable.
    All the examples below mean exactly* the same thing:
  </p>
  <textarea id="t5" style="display:none" autocomplete="off">
// Normal function declaration:
function testPaper(item) {
  return item.type === 'paper';
}

// Saving a function into the variable 'testPaper':
let testPaper = function (item) {
  return item.type === 'paper';
}

// When you are dealing with functions as variables,
// the word 'function' can be replaced by an arrow (=>):
let testPaper = (item) => {
  return item.type === 'paper';
}

// If the 'return' statement is the ONLY line of an arrow function,
// the braces and the word 'return' can be omitted:
let testPaper = (item) => item.type === 'paper';

// If your arrow function has EXACTLY ONE parameter,
// the parentheses can be omitted as well:
let testPaper = item => item.type === 'paper';
</textarea>
  <p><small>
    * JavaScript actually has some slight differences between arrow functions,
    functions declared as variables, and normally declared functions, but
    the differences are not important for the way we are using them in these lessons.
  </small></p>
  <p>
    This means that we don't even need to declare a function called <code>testPlastic</code>!
    We can pass the function declaration stright into <code>check</code>:
  </p>
  <textarea id="t6" style="display:none" autocomplete="off">
check({ name: 'Newspapers', type: 'paper' },     item => item.type === 'plastic');
check({ name: 'Milk bottles', type: 'plastic' }, item => item.type === 'plastic');
check({ name: 'Tin cans', type: 'metal' },       item => item.type === 'plastic');</textarea>
  <button data-textarea="t6" data-result="r6">Run</button>
  <pre id="r6" class="result"></pre>
  <p>
    Of course, we still <em>should</em> declare a function called <code>testPlastic</code>,
    because we are using it multiple times. But if we were only using it once,
    then we would be able to declare it like we have above.
  </p>
  <p>
    When a function is mentioned only once and is never assigned to a variable,
    it is often called an <strong>anonymous function</strong>.
  </p>
  <h3 id="conclusion-one">Putting it all together</h3>
  <p>
    Now we are finally ready to make that update to the recycling plant code
    so that it also prints how many of each item there are:
  </p>
  <textarea id="t7" style="display:none" autocomplete="off">
function check(item, test) {
  if (test(item)) {
    console.log('Yes! ' + item.amount + ' ' + item.name + ' can be recycled here.');
  } else {
    console.log('No! ' + item.amount + ' ' + item.name + ' must be recycled somewhere else.');
  }
}

let testPaper = item => item.type === 'paper';
let testPlastic = item => item.type === 'plastic';

console.log('Paper recycling:');
check({ name: 'Newspapers', type: 'paper', amount: 10 }, testPaper);
check({ name: 'Milk bottles', type: 'plastic', amount: 6 }, testPaper);
check({ name: 'Tin cans', type: 'metal', amount: 9 }, testPaper);

console.log('Plastic recycling:');
check({ name: 'Newspapers', type: 'paper', amount: 10 }, testPlastic);
check({ name: 'Milk bottles', type: 'plastic', amount: 6 }, testPlastic);
check({ name: 'Tin cans', type: 'metal', amount: 9 }, testPlastic);</textarea>
  <button data-textarea="t7" data-result="r7">Run</button>
  <pre id="r7" class="result"></pre>
  <p>
    Because the paper and plastic recycling plants are both using the same
    <code>check</code> function, we only had to make the update in one place,
    and it instantly worked for both recycling plants!
  </p>
  <p>
    We've also made it much easier to help the glass or metal recycling plants
    if they ever want to hire our services. Have a go at editing the code above,
    and see if you can work out how you would use <code>check</code>
    to help those other recycling plants.
  </p>
  <h2 id="lesson-two">Lesson Two</h2>
  <h3 id="filter">Filter</h3>
  <p>
    Thanks to you, the recycling plants are now a little more ordered, and they've
    put all their data into a list, but they'd still like it to be filtered
    into the different materials. Here is their list:
  </p>
  <pre class="recycling-list">const recycling = [
  { name: "Newspapers", type: "paper", amount: 10, weight: 220 },
  { name: "Milk bottles", type: "plastic", amount: 6, weight: 62 },
  { name: "Boxes", type: "paper", amount: 5, weight: 130 },
  { name: "Egg cartons", type: "paper", amount: 3, weight: 20 },
  { name: "Tin cans", type: "metal", amount: 9, weight: 20 },
  { name: "Magazines", type: "paper", amount: 2, weight: 150 },
  { name: "Glass bottles", type: "glass", amount: 7, weight: 600 },
  { name: "Yoghurt pots", type: "plastic", amount: 12, weight: 5 },
];</pre>
  <p>
    Have a go at writing a function that will return a new list
    of only the paper items.
  </p>
  <textarea id="t8" style="display:none" autocomplete="off">
function filterPaper(list) {
  
  
  
  
  
  
  
}

let filteredItems = filterPaper(recycling);
console.log(filteredItems);</textarea>
  <button data-textarea="t8" data-result="r8">Run</button>
  <button data-hint="t8" data-step="3">Hint (3)</button>
  <pre id="r8" class="result"></pre>
  <p>
    Can you tell what you'd have to change to create a <code>filterPlastic</code> function?
  </p>
  <p>
    If you've noticed that the only thing you'll need to change is the
    code inside the <code>if</code>-statement, then you might've also
    noticed that this looks really similar to the situation we were in last lesson.
  </p>
  <p>
    We don't really need to create separate functions called <code>filterPaper</code>
    and <code>filterPlastic</code>; we can just create a <strong>higher-order function</strong>
    called <code>filter</code>.
  </p>
  <p>
    Can you modify <code>filterPaper</code> to create the new <code>filter</code>
    function, that takes <code>test</code> as an argument?
  </p>
  <textarea id="t9" style="display:none" autocomplete="off">
function filterPaper(list) {
  let result = [];
  for (let item of list) {
    if (item.type === 'paper') {
      result.push(item);
    }
  }
  return result;
}

let filteredItems = filter(recycling, item => item.type === 'plastic');
console.log(filteredItems);</textarea>
  <button data-textarea="t9" data-result="r9">Run</button>
  <button data-hint="t9" data-step="2">Hint (2)</button>
  <pre id="r9" class="result"></pre>
  <p>
    As it turns out, <strong><code>filter</code></strong> is a library function
    in JavaScript, but instead of calling <code>filter(list, test)</code>,
    you call <code>list.filter(test)</code>.
  </p>
  <p>
    Play around with the code below and see if you can make it filter
    only the glass items, or only the items there are more than 6 of.
  </p>
  <textarea id="t10" style="display:none" autocomplete="off">
let filteredItems = recycling.filter(item => item.type === 'plastic');

console.log(filteredItems);</textarea>
  <button data-textarea="t10" data-result="r10">Run</button>
  <pre id="r10" class="result"></pre>
  <h3>Map</h3>
  <p>
    <strong><code>filter</code></strong> still leaves the recycling plants
    with a lot of information to look at. What they'd really like is if
    the resulting list only had the names of the items, and none of that
    extra information.
  </p>
  <p>
    Somebody working at the recycling plant has created the following function
    to map between a list of items and a list of names.
  </p>
  <textarea id="t11" style="display:none" autocomplete="off">
function mapNames(list) {
  let result = [];
  for (let item of list) {
    result.push(item.name);
  }
  return result;
}

let filteredItems = recycling.filter(item => item.type === 'paper');
let itemSummary = mapNames(filteredItems);

console.log(itemSummary);</textarea>
  <button data-textarea="t11" data-result="r11">Run</button>
  <pre id="r11" class="result"></pre>
  <p>
    But wouldn't you believe it! Now they've decided that they still need
    to see the amounts in brackets after the name. It wouldn't be super
    difficult to create another function called <code>mapNamesAndAmounts</code> that
    does almost the same thing as this function, but we've learnt by now
    that it isn't good practice to create two very similar functions,
    because it will be harder to keep them both up to date.
  </p>
  <p>
    So how would we go about creating a generic <code>map</code> function
    that could map from items to names, or from items to names and amounts,
    or from anything to anything? Think about what parts of the code need to
    change and what parts will be the same for all functions.
  </p>
  <textarea id="t12" style="display:none" autocomplete="off">
function mapNames(list) {
  let result = [];
  for (let item of list) {
    result.push(item.name);
  }
  return result;
}

let filteredItems = recycling.filter(item => item.type === 'paper');
let itemSummary = mapNames(filteredItems);

console.log(itemSummary);</textarea>
  <button data-textarea="t12" data-result="r12">Run</button>
  <button data-hint="t12" data-step="2">Hint (2)</button>
  <pre id="r12" class="result"></pre>
  <p>
    Just like with <strong><code>filter</code></strong>,
    <strong><code>map</code></strong> is a standard library function
    in JavaScript that is called with <code>list.map(selection)</code>.
  </p>
  <textarea id="t13" style="display:none" autocomplete="off">
// Print the first 5 square numbers
let squares = [1,2,3,4,5].map(x => x ** 2);
console.log(squares);

// Convert all the recycling item names to upper case
let loud = recycling.map(item => item.name.toUpperCase());
console.log(loud);</textarea>
  <button data-textarea="t13" data-result="r13">Run</button>
  <pre id="r13" class="result"></pre>
  <h3 id="chaining">Chaining functions</h3>
  <p>
    Being able to reuse code like this is useful,
    but it's not the only benefit of <strong><code>filter</code></strong>
    and <strong><code>map</code></strong>.
    Because they both operate on a list, they can be chained together
    one after another, without creating intermediate variables.
  </p>
  <p>
    Here is a fast way we could've gotten the names of paper items:
  </p>
  <textarea id="t14" style="display:none" autocomplete="off">
let result = recycling.filter(i => i.type === 'paper').map(i => i.name);

console.log(result);</textarea>
  <button data-textarea="t14" data-result="r14">Run</button>
  <pre id="r14" class="result"></pre>
  <p>
    And if we wanted to manipulate information
    from a comma separated text file like this one:
  </p>
  <pre class="recycling-list">Newspapers,paper,10,220
Milk bottles,plastic,6,62
Boxes,paper,5,130
Egg cartons,paper,3,20
Tin cans,metal,9,20
Magazines,paper,2,150
Glass bottles,glass,7,600
Yoghurt pots,plastic,12,5</pre>
  <p>
    Then with <strong><code>map</code></strong> it would be as
    simple as splitting it up and joining it back together again:
  </p>
  <textarea id="t15" style="display:none" autocomplete="off">
let result = textfile.split('\n').map(line => {
  let item = line.split(',');
  return item[2] + 'x ' + item[0] + ', each ' + item[3] + 'g of ' + item[1];
}).join('\n');

console.log(result);</textarea>
  <button data-textarea="t15" data-result="r15">Run</button>
  <pre id="r15" class="result"></pre>
  <p>
    One thing to be careful of when chaining functions is that
    you don't get too carried away. Sometimes it is nice to create
    more variables than is necessary, so that people can understand your code
    by breaking it up into nice easy chunks, instead of having to
    follow it from start to finish.
  </p>
  <h2 id="lesson-three">Lesson Three</h2>
  <h3 id="reduce">Reduce</h3>
  <p>
    So far we have been talking a lot about recycling and reusing code,
    but we've ignored the other big R word, and that is <strong><code>reduce</code></strong>.
  </p>
  <p>
    <strong><code>reduce</code></strong> is a <strong>higher-order function</strong>
    like <strong><code>filter</code></strong> and <strong><code>map</code></strong>,
    and it also operates on a list, but it doesn't produce a list as output.
    <strong><code>reduce</code></strong> is for grouping things together to produce
    a <em>single</em> output.
  </p>
  <p>
    Here is what the <strong><code>reduce</code></strong> function looks like,
    except that, as with <strong><code>filter</code></strong> and <strong><code>map</code></strong>,
    the version in the JavaScript standard library has the <code>list</code>
    on the outside, so it looks like <code>list.reduce(operation, startValue)</code>.
  </p>
  <textarea id="t16" style="display:none" autocomplete="off">
function reduce(list, operation, startValue) {
  let result = startValue;
  for (let item of list) {
    result = operation(result, item);
  }
  return result;
}</textarea>
  <p>
    This looks quite similar to <strong><code>filter</code></strong> and
    <strong><code>map</code></strong>, but we can also see some differences.
    Firstly, <strong><code>reduce</code></strong> takes an extra parameter – the
    <code>startValue</code> – because the result does not always start out
    as an empty array. But more importantly, the function parameter <code>operation</code>
    now takes two arguments: it doesn't just operate on the <code>item</code>; it also
    does something to add it to the result.
  </p>
  <p>
    The most common use of <strong><code>reduce</code></strong> is summing
    everything together. Below is an example of how you would sum things
    with reduce, and an expanded version that shows you how everything is put together:
  </p>
  <textarea id="t17" style="display:none" autocomplete="off">
let sum =
  [1,2,3,4,5].reduce((result, item) => result + item, 0);

// This is the same as the above
function reduceToSum(list) {
  let result = 0; // startValue = 0
  for (let item of list) {
    result = result + item; // operation(result, item) = result + item
  }
  return result;
}
sum = reduceToSum([1,2,3,4,5]);

console.log(sum);</textarea>
  <button data-textarea="t17" data-result="r17">Run</button>
  <pre id="r17" class="result"></pre>
  <p>
    The paper recycling plant would like to know how many
    items of all types they are receiving in total.
    How would you work this out using <strong><code>reduce</code></strong>?
  </p>
  <textarea id="t18" style="display:none" autocomplete="off">
let total =
  recycling.reduce( // ...?

console.log(total);</textarea>
  <button data-textarea="t18" data-result="r18">Run</button>
  <button data-hint="t18" data-step="3">Hint (3)</button>
  <pre id="r18" class="result"></pre>
  <p>
    Next they want to know only how many paper items
    they are collecting. What can you change to achieve this?
  </p>
  <textarea id="t19" style="display:none" autocomplete="off">
let total = recycling.reduce((result, item) => result + item.amount, 0);







console.log(total);</textarea>
  <button data-textarea="t19" data-result="r19">Run</button>
  <button data-hint="t19" data-step="4">Hint (4)</button>
  <pre id="r19" class="result"></pre>
  <p>
    Notice that in the above function, you still need to
    return the sum so far, even when you don't find a match.
    This is because the rest of the list needs that value
    so it can keep calculating the total.
  </p>
  <p>
    Of course, you could also perform the <strong><code>filter</code></strong>
    separately to the sum, and then chain them together:
  </p>
  <textarea id="t20" style="display:none" autocomplete="off">
let total =
  recycling
  .filter(item => item.type === 'paper')
  .reduce((result, item) => result + item.amount, 0);

console.log(total);</textarea>
<button data-textarea="t20" data-result="r20">Run</button>
<pre id="r20" class="result"></pre>
  <p>
    For a final challenge, the paper recycling plant would also
    like to know how much their total paper items weigh.
    The <code>weight</code> property in each recycling item
    is only the weight of a single item, so you would need to
    multiply this by the <code>amount</code>.
  </p>
  <p>
    There a two solutions presented below – one where the whole thing
    is done in <strong><code>reduce</code></strong> and one where
    <strong><code>reduce</code></strong> is chained with <strong><code>filter</code></strong>.
    Try to work out your own solution before looking at the ones provided.
  </p>
  
  <textarea id="t21" style="display:none" autocomplete="off">
let total =







console.log(total + 'g');</textarea>
  <button data-textarea="t21" data-result="r21">Run</button>
  <button data-hint="t21" data-step="0">Solve (Reduce only)</button>
  <button data-hint="t21" data-step="1">Solve (Filter and reduce)</button>
  <pre id="r21" class="result"></pre>
  <h3 id="all-you-need">Reduce is all you need</h3>
  <p>
    So why does <strong><code>reduce</code></strong> look so
    much more complicated than the other
    <strong>higher-order functions</strong> that we've seen?
  </p>
  <p>
    Well, as it turns out, <strong><code>reduce</code></strong>
    is so generic that it can be used to implement all the other
    list operations we've seen! The trick is to use an empty array
    as the <code>startValue</code>.
  </p>
  <p>
    Have a go at implementing <stong><code>map</code></stong> with
    <strong><code>reduce</code></strong>.
  </p>
  <textarea id="t22" style="display:none" autocomplete="off">
function map(list, selection) {
  return list.reduce( // ...?
}

let selectedNames = map(recycling, item => item.name);
console.log(selectedNames);</textarea>
  <button data-textarea="t22" data-result="r22">Run</button>
  <button data-hint="t22" data-step="3">Hint (3)</button>
  <pre id="r22" class="result"></pre>
  <p>
    Now try implementing <strong><code>filter</code></strong>.
  </p>
  <textarea id="t23" style="display:none" autocomplete="off">
function filter(list, test) {
  return list.reduce( // ...?
  
  
  
  
  
  
}

let filteredItems = filter(recycling, item => item.type === 'paper');
console.log(filteredItems);</textarea>
  <button data-textarea="t23" data-result="r23">Run</button>
  <button data-hint="t23" data-step="7">Hint (7)</button>
  <pre id="r23" class="result"></pre>
  <p>
    Next we are going to implement a new <strong>higher-order function</strong>
    with <strong><code>reduce</code></strong>, called <code>every</code>.
    It checks to see that every single item in a list matches the criteria in its
    <code>test</code> function.
  </p>
  <textarea id="t24" style="display:none" autocomplete="off">
function every(list, test) {
  return list.reduce( // ...?
}

// Every item in 'recycling' weighs less than 1kg:
let shouldBeTrue = every(recycling, item => item.weight &lt; 1000);
console.log(shouldBeTrue);

// Every item in 'recycling' is made of paper:
let shouldBeFalse = every(recycling, item => item.type === 'paper');
console.log(shouldBeFalse);</textarea>
  <button data-textarea="t24" data-result="r24">Run</button>
  <button data-hint="t24" data-step="3">Hint (3)</button>
  <pre id="r24" class="result"></pre>
  <p>
    <code>every</code> also appears in the JavaScript standard library as
    <code>list.every(test)</code>.
  </p>
  <h3 id="conclusion-three">What have I learned?</h3>
  <p>
    As well as being a great way to make sure you are reusing code
    and won't have to update things in multiple places,
    <strong>higher-order functions</strong> are found all over
    JavaScript with different purposes.
  </p>
  <p>
    <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener"><code>addEventListener</code></a>
    takes a function called a <code>handler</code>
    as its second argument, which tells it what to do when an event happens
    on the page.
  </p>
  <p>
    More advanced features like <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises"><code>Promises</code></a>
    take functions called <code>callbacks</code> as arguments,
    which they will run when they have finished
    performing their other tasks.
  </p>
  <p>
    An understanding of what <strong>higher-order functions</strong> are
    is a vital part of becoming a JavaScript programmer,
    and now you will know all about them when you come across them.
  </p>
  <script src="https://codemirror.net/lib/codemirror.js"></script>
  <script src="https://codemirror.net/mode/javascript/javascript.js"></script>
  <script>
document.querySelectorAll('textarea').forEach(textarea => {
  let editor = CodeMirror.fromTextArea(textarea, {
    lineNumbers: true,
    extraKeys: { Tab(e) { e.replaceSelection('  ', 'end'); } },
  });
  document.querySelectorAll(`button[data-textarea="${textarea.id}"]`).forEach(button => {
    button.addEventListener('click', () => {
      let result = document.querySelector(`#${button.getAttribute('data-result')}`);
      result.innerHTML = '';
      result.classList.remove('error');
      if (textarea.id === 't4' || textarea.id === 't6') {
        function check(item, test) {
          if (test(item)) {
            console.log('Yes! ' + item.name + ' can be recycled here.');
          } else {
            console.log('No! ' + item.name + ' must be recycled somewhere else.');
          }
        };
      }
      if (textarea.id.slice(1) > 7) {
        recycling = [
          { name: "Newspapers", type: "paper", amount: 10, weight: 220 },
          { name: "Milk bottles", type: "plastic", amount: 6, weight: 62 },
          { name: "Boxes", type: "paper", amount: 5, weight: 130 },
          { name: "Egg cartons", type: "paper", amount: 3, weight: 20 },
          { name: "Tin cans", type: "metal", amount: 9, weight: 20 },
          { name: "Magazines", type: "paper", amount: 2, weight: 150 },
          { name: "Glass bottles", type: "glass", amount: 7, weight: 600 },
          { name: "Yoghurt pots", type: "plastic", amount: 12, weight: 5 },
        ];
      }
      if (textarea.id === 't15') {
        textfile =
`Newspapers,paper,10,220
Milk bottles,plastic,6,62
Boxes,paper,5,130
Egg cartons,paper,3,20
Tin cans,metal,9,20
Magazines,paper,2,150
Glass bottles,glass,7,600
Yoghurt pots,plastic,12,5`;
      }
      let log = console.log;
      console.log = v => {
        let output = v;
        if (typeof v === 'object') {
          output = JSON.stringify(v, undefined, '  ');
        }
        result.innerHTML += output + '\n';
      }
      try {
        eval(editor.getDoc().getValue());
      } catch (e) {
        result.innerHTML = e;
        result.classList.add('error');
      }
      console.log = log;
    });
  });
  document.querySelectorAll(`button[data-hint="${textarea.id}"]`).forEach(button => {
    button.addEventListener('click', () => {
      let step = +button.getAttribute('data-step');
      let output = ({
        't8': [
`function filterPaper(list) {
  let result = [];
  for (let item of list) {
    if (item.type === 'paper') {
      result.push(item);
    }
  }
  return result;
}

let filteredItems = filterPaper(recycling);
console.log(filteredItems);`,
`function filterPaper(list) {
  let result = [];
  for (let item of list) {
    
      result.push(item);
    
  }
  return result;
}

let filteredItems = filterPaper(recycling);
console.log(filteredItems);`,
`function filterPaper(list) {
  let result = [];
  for (let item of list) {
    
    
    
  }
  return result;
}

let filteredItems = filterPaper(recycling);
console.log(filteredItems);`,
`function filterPaper(list) {
  let result = [];
  
  
  
  
  
  return result;
}

let filteredItems = filterPaper(recycling);
console.log(filteredItems);`,
        ],
        't9': [
`function filter(list, test) {
  let result = [];
  for (let item of list) {
    if (test(item)) {
      result.push(item);
    }
  }
  return result;
}

let filteredItems = filter(recycling, item => item.type === 'plastic');
console.log(filteredItems);`,
`function filter(list, test) {
  let result = [];
  for (let item of list) {
    if (item.type === 'paper') {
      result.push(item);
    }
  }
  return result;
}

let filteredItems = filter(recycling, item => item.type === 'plastic');
console.log(filteredItems);`,
`function filter(list) {
  let result = [];
  for (let item of list) {
    if (item.type === 'paper') {
      result.push(item);
    }
  }
  return result;
}

let filteredItems = filter(recycling, item => item.type === 'plastic');
console.log(filteredItems);`,
        ],
        't12': [
`function map(list, selection) {
  let result = [];
  for (let item of list) {
    result.push(selection(item));
  }
  return result;
}

let selectNamesAndAmounts = function(item) {
  return item.name + ' (' + item.amount + ')';
}

let filteredItems = recycling.filter(item => item.type === 'paper');
let itemSummary = map(filteredItems, selectNamesAndAmounts);

console.log(itemSummary);`,
`function map(list, selection) {
  let result = [];
  for (let item of list) {
    result.push(item.name);
  }
  return result;
}

let selectNamesAndAmounts = function(item) {
  return item.name + ' (' + item.amount + ')';
}

let filteredItems = recycling.filter(item => item.type === 'paper');
let itemSummary = map(filteredItems, selectNamesAndAmounts);

console.log(itemSummary);`,
`function mapNames(list) {
  let result = [];
  for (let item of list) {
    result.push(item.name);
  }
  return result;
}

let selectNamesAndAmounts = function(item) {
  return item.name + ' (' + item.amount + ')';
}

let filteredItems = recycling.filter(item => item.type === 'paper');
let itemSummary = map(filteredItems, selectNamesAndAmounts);

console.log(itemSummary);`,
        ],
        't18': [
        `let total =
  recycling.reduce((result, item) => result + item.amount, 0);

console.log(total);`,
`let total =
  recycling.reduce((result, item) => result + , 0);

console.log(total);`,
`let total =
  recycling.reduce((result, item) =>  , 0);

console.log(total);`,
`let total =
  recycling.reduce((result, item) =>  ,  );

console.log(total);`,
        ],
        't19': [
`let total = recycling.reduce((result, item) => {
  if (item.type === 'paper') {
    return result + item.amount;
  } else {
    return result;
  }
}, 0);

console.log(total);`,
`let total = recycling.reduce((result, item) => {
  if (item.type === 'paper') {
    return result + item.amount;
  } else {
    
  }
}, 0);

console.log(total);`,
`let total = recycling.reduce((result, item) => {
  if (item.type === 'paper') {
    return result + item.amount;
  }
  
  
}, 0);

console.log(total);`,
`let total = recycling.reduce((result, item) => {
  if ( ) {
    return result + item.amount;
  }
  
  
}, 0);

console.log(total);`,
`let total = recycling.reduce((result, item) => {
  
    return result + item.amount;
  
  
  
}, 0);

console.log(total);`,
        ],
        't21': [
`let total = recycling.reduce((result, item) => {
  if (item.type === 'paper') {
    return result + item.amount * item.weight;
  } else {
    return result;
  }
}, 0);

console.log(total + 'g');`,
`let total =
  recycling
  .filter(item => item.type === 'paper')
  .reduce((result, item) => result + item.amount * item.weight, 0);




console.log(total + 'g');`,
        ],
        't22': [
        `function map(list, selection) {
  return list.reduce((result, item) => result.concat(selection(item)), []);
}

let selectedNames = map(recycling, item => item.name);
console.log(selectedNames);`,
`function map(list, selection) {
  return list.reduce((result, item) => result.concat( ), []);
}

let selectedNames = map(recycling, item => item.name);
console.log(selectedNames);`,
`function map(list, selection) {
  return list.reduce((result, item) =>  , []);
}

let selectedNames = map(recycling, item => item.name);
console.log(selectedNames);`,
`function map(list, selection) {
  return list.reduce((result, item) =>  ,  );
}

let selectedNames = map(recycling, item => item.name);
console.log(selectedNames);`,
        ],
        't23': [
`function filter(list, test) {
  return list.reduce((result, item) => {
    if (test(item)) {
      return result.concat(item);
    } else {
      return result;
    }
  }, []);
}

let filteredItems = filter(recycling, item => item.type === 'paper');
console.log(filteredItems);`,
`function filter(list, test) {
  return list.reduce((result, item) => {
    if (test(item)) {
      return result.concat(item);
    } else {
      
    }
  }, []);
}

let filteredItems = filter(recycling, item => item.type === 'paper');
console.log(filteredItems);`,
`function filter(list, test) {
  return list.reduce((result, item) => {
    if (test(item)) {
      return result.concat(item);
    }
    
    
  }, []);
}

let filteredItems = filter(recycling, item => item.type === 'paper');
console.log(filteredItems);`,
`function filter(list, test) {
  return list.reduce((result, item) => {
    if (test(item)) {
      return result.concat( );
    }
    
    
  }, []);
}

let filteredItems = filter(recycling, item => item.type === 'paper');
console.log(filteredItems);`,
`function filter(list, test) {
  return list.reduce((result, item) => {
    if (test(item)) {
      
    }
    
    
  }, []);
}

let filteredItems = filter(recycling, item => item.type === 'paper');
console.log(filteredItems);`,
`function filter(list, test) {
  return list.reduce((result, item) => {
    if ( ) {
      
    }
    
    
  }, []);
}

let filteredItems = filter(recycling, item => item.type === 'paper');
console.log(filteredItems);`,
`function filter(list, test) {
  return list.reduce((result, item) => {
    
    
    
    
    
  }, []);
}

let filteredItems = filter(recycling, item => item.type === 'paper');
console.log(filteredItems);`,
`function filter(list, test) {
  return list.reduce((result, item) => {
    
    
    
    
    
  },  );
}

let filteredItems = filter(recycling, item => item.type === 'paper');
console.log(filteredItems);`,
        ],
        't24': [
`function every(list, test) {
  return list.reduce((result, item) => result && test(item), true);
}

// Every item in 'recycling' weighs less than 1kg:
let shouldBeTrue = every(recycling, item => item.weight < 1000);
console.log(shouldBeTrue);

// Every item in 'recycling' is made of paper:
let shouldBeFalse = every(recycling, item => item.type === 'paper');
console.log(shouldBeFalse);`,
`function every(list, test) {
  return list.reduce((result, item) => result &&  , true);
}

// Every item in 'recycling' weighs less than 1kg:
let shouldBeTrue = every(recycling, item => item.weight < 1000);
console.log(shouldBeTrue);

// Every item in 'recycling' is made of paper:
let shouldBeFalse = every(recycling, item => item.type === 'paper');
console.log(shouldBeFalse);`,
`function every(list, test) {
  return list.reduce((result, item) =>  , true);
}

// Every item in 'recycling' weighs less than 1kg:
let shouldBeTrue = every(recycling, item => item.weight < 1000);
console.log(shouldBeTrue);

// Every item in 'recycling' is made of paper:
let shouldBeFalse = every(recycling, item => item.type === 'paper');
console.log(shouldBeFalse);`,
`function every(list, test) {
  return list.reduce((result, item) => ,  );
}

// Every item in 'recycling' weighs less than 1kg:
let shouldBeTrue = every(recycling, item => item.weight < 1000);
console.log(shouldBeTrue);

// Every item in 'recycling' is made of paper:
let shouldBeFalse = every(recycling, item => item.type === 'paper');
console.log(shouldBeFalse);`,
        ],
      })[textarea.id][step];
      editor.getDoc().setValue(output);
      if (textarea.id !== 't21') {
        step--;
        if (step < 0) { step = 0; }
        button.setAttribute('data-step', step);
        button.textContent = step ? `Hint (${step})` : 'Solve';
      }
    });
  });
});
  </script>
</body>
</html>
